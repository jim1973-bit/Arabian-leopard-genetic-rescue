initialize() {
	initializeSLiMModelType("WF");
	initializeTreeSeq(simplificationInterval=25);
	// initializeTreeSeq(checkCoalescence=T);
	// define constant is a good way to set up parameters
	// there are two way to input parameters from the command line. The option below says that when you are in the GUI the values are taken from here, if not the simulation will expect to be define from the command line
	
	// the way to run from the command line is 
	// slim -t -d "parameter=value" slim_script.slim
	// -t is to time the run
	if (exists("slimgui"))
	{
		defineConstant("bg_rho",0.001); // between gene recombination rate
		defineConstant("wg_rho",1e-8); // within gene recombination rate
		defineConstant("mu",2.4e-8); // mutation rate
		defineConstant("Seed",getSeed()); // gets seed
		defineConstant("g",1000); // number of genes per autosome
		defineConstant("geneLength",1500); // length (bp) of gene 
		defineConstant("autoNo",18); // number of autosomes
		defineConstant("pathto",PATH_TO_FOLDER_DESTINATION_WHEN_USING_SLiMGUI);
	}
	else {
		defineConstant("pathto",PATH_TO_FOLDER_DESTINATION_WHEN_USING_BASH);
	}
	
	
	// the second way is to say, if the variable does not exist then taken if from here
	if (exists("outPref_in")==0){
		defineConstant("outPref_in","test_TOM_slim");       // this variable defines the prefix for the output file
	}
	// mutation types
	hs=readFile(paste(pathto,PATH_TO_MUTATIONS_FILE,"/Mutations_Seed_"+getSeed()+".txt", sep="")); // Imports mutations generated by Burn_in_1.slim
	hs=hs[1:(length(hs)-1)];
	s=sapply(hs,"asFloat(strsplit(applyValue,'\t')[2]);");
	del_mut=length(s);
	h=sapply(hs,"asFloat(strsplit(applyValue,'\t')[1]);");
	prop=rep(1/1000,del_mut);
	prop_exons=sapply(prop,"(applyValue);");
	// define mutation types	
	for (i in 0:(length(prop)-1))
	{
		initializeMutationType(i+2, h[i], "f", asFloat(s[i]));
		print("mut:"+(i+2)+" - " + "h:"+h[i]+" - "+ "s:" + asFloat(s[i]));
	}
	
	
	// distribution of mutation types
	initializeGenomicElementType("g1", 1:(del_mut), c(prop_exons));
	initializeMutationRate(mu);
	
	
	initializeGenomicElement(g1, 0, asInteger((geneLength*g*autoNo)-1));
	
		// creates the autosomes
	rates=NULL; 
	rates = c(rep(c(wg_rho,bg_rho),(g-1)), wg_rho);
	rates = c(rep(c(rates,0.5),(autoNo-1)),rates);
	ends=NULL;
	for (i in 1:(g-1)) {
		ends = c(ends,((i*geneLength)-1),(i*geneLength));
	}
	ends = c(ends,(g*geneLength)-1);
	nends = ends + (g*geneLength);
	nends = c(ends[length(ends)-1]+1,nends);
	for (i in 1:(autoNo-1)) {
		ends = c(ends,nends);
		nends = nends + (g*geneLength);
	}
	initializeRecombinationRate(rates, asInteger(ends));
	
	initializeSex("A");
}


1 {
	sim.readFromPopulationFile(paste(pathto,DESTINATION_CONTAINING_.trees_FILE_OF_POPULATION_FOR_BURN_IN_1,"/OpTree_Seed"+getSeed()+"_Gen590000.trees", sep="")); // Load population from .trees file generated by Burn_in_1.slim
	sim.mutationTypes.convertToSubstitution=F;
	sim.mutationTypes.mutationStackPolicy="l";
	
	// our prefix + parameters
	
	
	setwd(paste(pathto,DESTINATION_CONTAINING_GENETIC_LOAD_FILES, sep = "")); // Destination for genetic load data files
	
	HEAD="Gen" +"\t" + "pop" +"\t"+ "N"+"\t"+ "mutCount" +"\t"+ "Pop_size" +"\t"+ "NA" +"\t"+ "totalLoad" +"\t"+ "relzLoad" +"\t"+ "relzLoad_homo" +"\t"+ "relzLoad_hetero" +"\t"+ "mskLoad" +"\t"+ "mean_fit(ind)" +"\t"+ "sd_fit(ind)" +"\t"+ "mean_fit(cached)" +"\t"+ "sd_fit(cached)";
	writeFile("GLoad_Seed"+getSeed()+ "_.txt",HEAD,append=F);  // Creates file with headers of genetic load data
	
	
	print("################");
	print("\n" + outPref + "\n");
	print("################");

}


/// Print progress
1: late() {
	if(sim.generation == 1 | sim.generation % 100 ==0){
		print(date() + "\t" + time() + "\t" + "generation: " + sim.generation + "\t" + "N: " + p1.individualCount+ "  memory usage: "+usage()/1000+"Gb");
	}
}

1: {
	if(sim.generation % 100 ==0){
		print("Outoput metrics" + "\t" + sim.generation + "\t" + time() + "\t" + date());
		setwd(paste(pathto,DESTINATION_CONTAINING_GENETIC_LOAD_FILES, sep = ""));
		OUT=getPopSumm(p1, 100);  // uses the getPopSumm() function to produce genetic load data every 100 generations
		writeFile("GLoad_Seed"+getSeed()+ "_.txt",OUT,append=T);
	}
}

590000: {
	if (sim.generation % 2000 == 0){   // Output population every 2000 generation in the form of .trees files
		setwd(paste(pathto,DESTINATION_OF_.trees_FILES_FOR_THIS_SIMULATION, sep = ""));
		sim.treeSeqOutput("OpTree_Seed"+getSeed()+"_Gen" + sim.generation +".trees");
	}
}




600000 late() { sim.simulationFinished(); }




//Functions

function (s) getPopSumm(o pop, i sampleSize)  // Calculates genetic load, realised load, homozygous realised load, heterozygous realised load, masked load, and mean fitness
{
	Pop_size = pop.individualCount;
	mNeutral=sim.mutationTypes[sim.mutationTypes.id==mut_neutral];
	i=pop.sampleIndividuals(sampleSize);
	indvCount=length(i);
	m = i.uniqueMutations;
	m_uniq = unique(m);
	m_uniq=m_uniq[m_uniq.mutationType!=mNeutral];
	Mutcount=length(m_uniq);
	freqMut=sim.mutationFrequencies(pop,m_uniq);
	ScoefMut=abs(m_uniq.selectionCoeff);
	DcoefMut=m_uniq.mutationType.dominanceCoeff;
	//	HomRef=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==F&i.genome2.containsMutations(applyValue)==F)/i.size();");
	//	HomAlt=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==T&i.genome2.containsMutations(applyValue)==T)/i.size();");
	//	Het1=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==F&i.genome2.containsMutations(applyValue)==T)/i.size();");
	//	Het2=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==T&i.genome2.containsMutations(applyValue)==F)/i.size();");
	//	Het=(Het1+Het2);
	//	mHet=mean(Het);
	totalLoad=sum(freqMut*ScoefMut);
	relzLoad_homo=sum(freqMut^2*ScoefMut);
	relzLoad_hetero=2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut);
	relzLoad=sum(freqMut^2*ScoefMut)+ (2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut));
	mskLoad=sum(freqMut*ScoefMut) - sum(freqMut^2*ScoefMut) - (2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut));
	
	fitness_indv=c();
	for(indv in pop.individuals){
		// Calculate individual fitness
		muts0_m2 = indv.genomes[0].mutations;
		muts1_m2 = indv.genomes[1].mutations;
		HOMO_m2=setIntersection(muts0_m2,muts1_m2);
		HETERO_m2=setSymmetricDifference(muts0_m2,muts1_m2);
		if(length(HETERO_m2)>0){fit_hetero=1-(abs(HETERO_m2.selectionCoeff)*HETERO_m2.mutationType.dominanceCoeff);}
		if(length(HETERO_m2)==0){fit_hetero=1;}
		fit_homo=1-abs(HOMO_m2.selectionCoeff);
		if(length(fit_homo)==0){fit_homo=1;}
		indv_fit=product(c(fit_hetero,fit_homo));
		fitness_indv=c(fitness_indv,indv_fit);
	}
	
	fitness_cached=pop.cachedFitness(pop.individuals.index);
	
	
	out=sim.generation +"\t"+ pop.id +"\t"+ indvCount +"\t"+ Mutcount +"\t"+ Pop_size +"\t"+ "NA" +"\t"+ totalLoad +"\t"+ relzLoad +"\t"+ relzLoad_homo +"\t"+ relzLoad_hetero +"\t"+ mskLoad +"\t"+mean(fitness_indv)+"\t"+sd(fitness_indv)+"\t"+mean(fitness_cached)+"\t"+sd(fitness_cached);
	return(out);
}


