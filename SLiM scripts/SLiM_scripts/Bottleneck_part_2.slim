initialize() {
	initializeSLiMModelType("WF");
	initializeTreeSeq(simplificationInterval=1);
	if (exists("slimgui"))
	{	
		setSeed(58);
		defineConstant("bg_rho",0.001); // between gene recombination rate
		defineConstant("wg_rho",1e-8); // within gene recombination rate
		defineConstant("mu",2.4e-7); // mutation rate
		defineConstant("Seed",getSeed()); // gets seed
		defineConstant("g",1000); // stets number of genes per autosome 
		defineConstant("geneLength",1500); // sets size of each gene in bps
		defineConstant("pathto",PATH_TO_FOLDER_DESTINATION_WHEN_USING_SLiMGUI);
	}
	else {
		defineConstant("pathto",PATH_TO_FOLDER_DESTINATION_WHEN_USING_BASH);
	}
	

	// mutation types
	hs=readFile(paste(pathto,PATH_TO_MUTATIONS_FILE,"/Mutations_Seed_"+getSeed()+".txt", sep="")); // Imports mutations generated by Burn_in_1.slim
	hs=hs[1:(length(hs)-1)];
	s=sapply(hs,"asFloat(strsplit(applyValue,'\t')[2]);");
	del_mut=length(s);
	h=sapply(hs,"asFloat(strsplit(applyValue,'\t')[1]);");
	prop=rep(1/1000,del_mut);
	prop_exons=sapply(prop,"(applyValue);");
	// define mutation types	
	for (i in 0:(length(prop)-1))
	{
		initializeMutationType(i+2, h[i], "f", asFloat(s[i]));
		print("mut:"+(i+2)+" - " + "h:"+h[i]+" - "+ "s:" + asFloat(s[i]));
	}

	
	// distribution of mutation types
	initializeGenomicElementType("g1", 1:(del_mut), c(prop_exons));
	initializeMutationRate(mu);
	
	initializeGenomicElement(g1, 0, asInteger((geneLength*g*autoNo)-1));
	
	// creates the autosomes
	rates=NULL;
	rates = c(rep(c(wg_rho,bg_rho),(g-1)), wg_rho);
	rates = c(rep(c(rates,0.5),(autoNo-1)),rates);
	ends=NULL;
	for (i in 1:(g-1)) {
		ends = c(ends,((i*geneLength)-1),(i*geneLength));
	}
	ends = c(ends,(g*geneLength)-1);
	nends = ends + (g*geneLength);
	nends = c(ends[length(ends)-1]+1,nends);
	for (i in 1:(autoNo-1)) {
		ends = c(ends,nends);
		nends = nends + (g*geneLength);
	}
	initializeRecombinationRate(rates, asInteger(ends));
	
	initializeSex("A");
}


1 {
	sim.readFromPopulationFile(paste(pathto,DESTINATION_CONTAINING_.trees_FILE_OF_POPULATION_FOR_Bottleneck_part_1.slim,"/OpTree_Seed"+getSeed()+"_Gen602000.trees", sep=""));  // Loads population from Bottleneck_part_1.slim
	sim.recalculateFitness();
	sim.mutationTypes.convertToSubstitution=F;
	sim.mutationTypes.mutationStackPolicy="l";
	
	setwd(paste(pathto,DESTINATION_CONTAINING_GENETIC_LOAD_FILES, sep = "")); // Destination for genetic load data files
	
	
	// Creates file with headers of genetic load data for both Wild and Captive populations
	
	HEAD="Gen" +"\t" + "pop" +"\t"+ "N"+"\t"+ "mutCount" +"\t"+ "Pop_size" +"\t"+ "NA" +"\t"+ "totalLoad" +"\t"+ "relzLoad" +"\t"+ "relzLoad_homo" +"\t"+ "relzLoad_hetero" +"\t"+ "mskLoad" +"\t"+ "mean_fit(ind)" +"\t"+ "sd_fit(ind)" +"\t"+ "mean_fit(cached)" +"\t"+ "sd_fit(cached)";
	writeFile("Wild_GLoad_Seed"+getSeed()+ "_.txt",HEAD,append=F);
	
	HEAD="Gen" +"\t" + "pop" +"\t"+ "N"+"\t"+ "mutCount" +"\t"+ "Pop_size" +"\t"+ "NA" +"\t"+ "totalLoad" +"\t"+ "relzLoad" +"\t"+ "relzLoad_homo" +"\t"+ "relzLoad_hetero" +"\t"+ "mskLoad" +"\t"+ "mean_fit(ind)" +"\t"+ "sd_fit(ind)" +"\t"+ "mean_fit(cached)" +"\t"+ "sd_fit(cached)";
	writeFile("Captive_GLoad_Seed"+getSeed()+ "_.txt",HEAD,append=F);
	
	print("################");
	print("\n" + outPref + "\n");
	print("################");

}


/// Print progress
1: late() {
	if(sim.generation == 1 | sim.generation % 100 ==0){
		print(date() + "\t" + time() + "\t" + "generation: " + sim.generation + "\t" + "N: " + p1.individualCount+ "  memory usage: "+usage()/1000+"Gb");
	}
}


602001 { sim.addSubpopSplit("p2", 64, p1); } // creates captive population, p2, by taking 64 individuals from the wild popualtion, p1
	

602001:602024 {p1.setSubpopulationSize(asInteger(110+((836/24)*(602024-sim.generation)))); // causes linear decline of wild population to 110 individuals
print(p1.individualCount); }

 

602002: {
	print("Outoput metrics" + "\t" + sim.generation + "\t" + time() + "\t" + date());
	setwd(paste(pathto,DESTINATION_CONTAINING_GENETIC_LOAD_FILES, sep = ""));
	// uses the getPopSumm() function to produce genetic load data every generations for wild and captive populations
	OUT=getPopSumm(p1, 100);
	writeFile(outPref + "_popLoad_Wild.txt",OUT,append=T);
	OUT=getPopSumm(p2, 64);
	writeFile(outPref + "_popLoad_Captive.txt",OUT,append=T);
}






602001:602024 {  // Output population every generation in the form of .trees files
	setwd(paste(pathto,DESTINATION_OF_.trees_FILES_FOR_THIS_SIMULATION, sep = ""));
	sim.treeSeqOutput("OpTree_Seed"+getSeed()+"_Gen" + sim.generation +".trees");
}



602024 late() { sim.simulationFinished(); }




//Functions



function (s) getPopSumm(o pop, i sampleSize) // Calculates genetic load, realised load, homozygous realised load, heterozygous realised load, masked load, and mean fitness
{
	Pop_size = pop.individualCount;
	mNeutral=sim.mutationTypes[sim.mutationTypes.id==mut_neutral];
	i=pop.sampleIndividuals(sampleSize);
	indvCount=length(i);
	m = i.uniqueMutations;
	m_uniq = unique(m);
	m_uniq=m_uniq[m_uniq.mutationType!=mNeutral];
	Mutcount=length(m_uniq);
	freqMut=sim.mutationFrequencies(pop,m_uniq);
	ScoefMut=abs(m_uniq.selectionCoeff);
	DcoefMut=m_uniq.mutationType.dominanceCoeff;
	//	HomRef=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==F&i.genome2.containsMutations(applyValue)==F)/i.size();");
	//	HomAlt=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==T&i.genome2.containsMutations(applyValue)==T)/i.size();");
	//	Het1=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==F&i.genome2.containsMutations(applyValue)==T)/i.size();");
	//	Het2=sapply(m_uniq, "sum(i.genome1.containsMutations(applyValue)==T&i.genome2.containsMutations(applyValue)==F)/i.size();");
	//	Het=(Het1+Het2);
	//	mHet=mean(Het);
	totalLoad=sum(freqMut*ScoefMut);
	relzLoad_homo=sum(freqMut^2*ScoefMut);
	relzLoad_hetero=2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut);
	relzLoad=sum(freqMut^2*ScoefMut)+ (2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut));
	mskLoad=sum(freqMut*ScoefMut) - sum(freqMut^2*ScoefMut) - (2*sum(freqMut*(1-freqMut)*ScoefMut*DcoefMut));
	
	fitness_indv=c();
	for(indv in pop.individuals){
		// Calculate individual fitness
		muts0_m2 = indv.genomes[0].mutations;
		muts1_m2 = indv.genomes[1].mutations;
		HOMO_m2=setIntersection(muts0_m2,muts1_m2);
		HETERO_m2=setSymmetricDifference(muts0_m2,muts1_m2);
		if(length(HETERO_m2)>0){fit_hetero=1-(abs(HETERO_m2.selectionCoeff)*HETERO_m2.mutationType.dominanceCoeff);}
		if(length(HETERO_m2)==0){fit_hetero=1;}
		fit_homo=1-abs(HOMO_m2.selectionCoeff);
		if(length(fit_homo)==0){fit_homo=1;}
		indv_fit=product(c(fit_hetero,fit_homo));
		fitness_indv=c(fitness_indv,indv_fit);
	}
	
	fitness_cached=pop.cachedFitness(pop.individuals.index);
	
	
	out=sim.generation +"\t"+ pop.id +"\t"+ indvCount +"\t"+ Mutcount +"\t"+ Pop_size +"\t"+ "NA" +"\t"+ totalLoad +"\t"+ relzLoad +"\t"+ relzLoad_homo +"\t"+ relzLoad_hetero +"\t"+ mskLoad +"\t"+mean(fitness_indv)+"\t"+sd(fitness_indv)+"\t"+mean(fitness_cached)+"\t"+sd(fitness_cached);
	return(out);
}


